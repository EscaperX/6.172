**Homework 1: Getting Started**

Write-up 1
----------
~~~c
#include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>

    int main(int argc, char * argv[]) {  // What is the type of argv?
        // array of char pointer
      int i = 5;
      // The & operator here gets the address of i and stores it into pi
      int * pi = &i;
      // The * operator here dereferences pi and stores the value -- 5 --
      // into j.
      int j = *pi;

      char c[] = "6.172";
      char * pc = c;  // Valid assignment: c acts like a pointer to c[0] here.
      char d = *pc;
      printf("char d = %c\n", d);  // What does this print?

      // compound types are read right to left in C.
      // pcp is a pointer to a pointer to a char, meaning that
      // pcp stores the address of a char pointer.
      char ** pcp;
      pcp = argv;  // Why is this assignment valid?
      // argv is an array of char pointer, pcp points to the first char of the first char * in the array.

      const char * pcc = c;  // pcc is a pointer to char constant
      char const * pcc2 = c;  // What is the type of pcc2?
      // pcc2 is a const pointer to char variable

      // For each of the following, why is the assignment:
      *pcc = '7';  // invalid?
      // Yes. pcc is point to a char constant, so the content can't be modified.

      pcc = *pcp;  // valid?
      // valid, pcc is a pointer so its address can be modified, which means it can point to another char and regard it as constant.

      pcc = argv[0];  // valid?
      // valid, same to the case above

      char * const cp = c;  // cp is a const pointer to char
      // For each of the following, why is the assignment:
      cp = *pcp;  // invalid?
      // invalid. cp can't point to another memory
      cp = *argv;  // invalid?
      // invalid, same to the case above
      *cp = '!';  // valid?
        // valid, the content can be modified
      const char * const cpc = c;  // cpc is a const pointer to char const
      // For each of the following, why is the assignment:
      cpc = *pcp;  // invalid?
      cpc = argv[0];  // invalid?
      *cpc = '@';  // invalid?
        // neither modification on address or content is allowed.
      return 0;
    }
~~~

Write-up 3
----------
~~~
size of int : 4 bytes
size of student : 8 bytes
size of int : 4 bytes, sizeof pointer: 8 bytes
size of short : 2 bytes, sizeof pointer: 8 bytes
size of float : 4 bytes, sizeof pointer: 8 bytes
size of long : 4 bytes, sizeof pointer: 8 bytes
size of char : 1 bytes, sizeof pointer: 8 bytes
size of double : 8 bytes, sizeof pointer: 8 bytes
size of unsigned int : 4 bytes, sizeof pointer: 8 bytes
size of long long : 8 bytes, sizeof pointer: 8 bytes
size of uint8_t : 1 bytes, sizeof pointer: 8 bytes
size of uint16_t : 2 bytes, sizeof pointer: 8 bytes
size of uint32_t : 4 bytes, sizeof pointer: 8 bytes
size of uint64_t : 8 bytes, sizeof pointer: 8 bytes
size of uintfast8_t : 1 bytes, sizeof pointer: 8 bytes
size of uintfast16_t : 4 bytes, sizeof pointer: 8 bytes
size of uintmax_t : 8 bytes, sizeof pointer: 8 bytes
size of intmax_t : 8 bytes, sizeof pointer: 8 bytes
size of __int128 : 16 bytes, sizeof pointer: 8 bytes
~~~

There're some difference on the size of long long and uint_fast16_t between the reference and my operating system.
( "long long", 8 ),( "uint_fast16_t", 8 )

Write-up 4
----------
see [this code](c-primer/swap.c)

Write-up 5
----------
Skip

Write-up 6
----------
~~~
Setup
Running matrix_multiply_run()...
Elapsed execution time: 0.000000 sec

=================================================================
==1154==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 48 byte(s) in 3 object(s) allocated from:
    #0 0x494b2d in malloc (/mnt/c/Users/Administrator/OneDrive/ZJU/6.172/assignments/hw1/matrix-multiply/matrix_multiply+0x494b2d)
    #1 0x4c4ed9 in make_matrix /mnt/c/Users/Administrator/OneDrive/ZJU/6.172/assignments/hw1/matrix-multiply/matrix_multiply.c:39:24
    #2 0x7f7acfbaf082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16

Indirect leak of 192 byte(s) in 12 object(s) allocated from:
    #0 0x494b2d in malloc (/mnt/c/Users/Administrator/OneDrive/ZJU/6.172/assignments/hw1/matrix-multiply/matrix_multiply+0x494b2d)
    #1 0x4c4f67 in make_matrix /mnt/c/Users/Administrator/OneDrive/ZJU/6.172/assignments/hw1/matrix-multiply/matrix_multiply.c:48:35

Indirect leak of 96 byte(s) in 3 object(s) allocated from:
    #0 0x494b2d in malloc (/mnt/c/Users/Administrator/OneDrive/ZJU/6.172/assignments/hw1/matrix-multiply/matrix_multiply+0x494b2d)
    #1 0x4c4f20 in make_matrix /mnt/c/Users/Administrator/OneDrive/ZJU/6.172/assignments/hw1/matrix-multiply/matrix_multiply.c:46:31
    #2 0x7f7acfbaf082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16

SUMMARY: AddressSanitizer: 336 byte(s) leaked in 18 allocation(s).

~~~

Write-up 7
----------
~~~
Result:
------------
   47     55    122    130
   79     83    138    164
   74     40     75    114
  130     95     74    144
------------
~~~

Write-up 8
----------
~~~
---- END RESULTS ----
Elapsed execution time: 0.000797 sec
==1566==
==1566== HEAP SUMMARY:
==1566==     in use at exit: 336 bytes in 18 blocks
==1566==   total heap usage: 39 allocs, 21 frees, 1,680 bytes allocated
==1566==
==1566== LEAK SUMMARY:
==1566==    definitely lost: 48 bytes in 3 blocks
==1566==    indirectly lost: 288 bytes in 15 blocks
==1566==      possibly lost: 0 bytes in 0 blocks
==1566==    still reachable: 0 bytes in 0 blocks
==1566==         suppressed: 0 bytes in 0 blocks
==1566== Rerun with --leak-check=full to see details of leaked memory
==1566==
==1566== For lists of detected and suppressed errors, rerun with: -s
==1566== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
~~~

Write-up 9
----------

Because there's no way for me to use awsrun, so I use bash command -- 'time' for a rough estimation.

~~~
Setup
Running matrix_multiply_run()...
Elapsed execution time: 0.000000 sec

real 0m0.006s
user 0m0.002s
sys 0m0.000s
~~~

Increase the kMatrixSize to 1000
~~~
Setup
Running matrix_multiply_run()...
Elapsed execution time: 1.709512 sec
 
real 0m1.730s
user 0m1.726s
sys 0m0.000s
~~~

Swap the loop order of j and k:
~~~
Setup
Running matrix_multiply_run()...
Elapsed execution time: 0.735511 sec

real 0m0.757s
user 0m0.752s
sys 0m0.000s
~~~

Write-up 10
----------
Compile in O0:
~~~
Setup
Running matrix_multiply_run()...
Elapsed execution time: 3.831889 sec

real 0m3.869s
user 0m3.833s
sys 0m0.020s
~~~

Compile in O3
~~~
Setup
Running matrix_multiply_run()...
Elapsed execution time: 0.765400 sec

real 0m0.786s
user 0m0.782s
sys 0m0.000s
~~~


<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
